import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import xml.etree.ElementTree as ET
import sys, csv, os
from shapely.geometry import Polygon, Point, MultiPoint
import cv2
from multiprocessing import Pool
from functools import partial

# def par_trace(pt, frame, poly):
#     # print(len(pt_frame))
#     if poly.contains(pt):
#         return frame[int(pt.y*2)][int(pt.x *2)]
#     else:
#         return 0.0




def load_data(file_icy, file_dlc, drop = True, threshold = 0.5, scale = (2, 2)):
    '''
    :param file_icy: .xml file of hydra contour generated by ICY
    :param file_dlc: .csv file of tracked points generated by DeepLabCut
    :param drop: bool; True if to drop bad frames, otherwise do nothing
    :param threshold: float; threshold for drop
    :return: coordinates of contour, coordinates of tracked points, index of bad frames
    :rtype: list, pandas.core.frame.DataFrame, numpy.array
    '''

    # Extract coordinates from file_icy
    root = ET.parse(file_icy).getroot()
    rois = root.find('rois').findall('roi')
    contours = []
    for roi in rois[1:]:
        points = roi.find('points').findall('point')
        contour = []
        for point in points:
            pos_x = float(point.find('pos_x').text)
            pos_y = float(point.find('pos_y').text)
            contour.append((pos_x, pos_y))
        contours.append(contour)

    # Extract coordinates from file_dlc
    df = pd.read_csv(file_dlc)
    df.columns = ['scorer', 'hypostome_x', 'hypostome_y', 'hypostome_likelihood',
              'armpit1_x', 'armpit1_y', 'armpit1_likelihood',
              'armpit2_x', 'armpit2_y', 'armpit2_likelihood',
              'peduncle_x', 'peduncle_y', 'peduncle_likelihood']
    df = df.drop(index = [0,1]).drop(columns='scorer').reset_index(drop = True)
    df = df.astype(float)

    # Scale coordinates
    df[['hypostome_x', 'peduncle_x', 'armpit1_x', 'armpit2_x']] /= scale[0]
    df[['hypostome_y', 'peduncle_y', 'armpit1_y', 'armpit2_y']] /= scale[1]

    if drop: inds_bad = drop_bad_frames(df, threshold)

    return contours, df, inds_bad

def drop_bad_frames(df, threshold):
    '''
    Drop frames of which any likelihood is lower than threshold
    :return: index of dropped frames
    '''
    inds = df.index.values
    inds_good = df[df['hypostome_likelihood'] > threshold].index.values
    inds_good = np.intersect1d(inds_good, df[df['armpit1_likelihood'] > threshold].index.values, assume_unique = True)
    inds_good = np.intersect1d(inds_good, df[df['armpit2_likelihood'] > threshold].index.values, assume_unique = True)
    inds_good = np.intersect1d(inds_good, df[df['peduncle_likelihood'] > threshold].index.values, assume_unique = True)

    inds_bad = np.setdiff1d(inds, inds_good)
    df.iloc[inds_bad] = None

    return inds_bad

def locate_point(marker, contour):
    '''
    Locate the corresponding index of the marker on contour
    :return: int; index of marker
    '''
    index = 0
    mindist = np.inf
    for j in range(len(contour)):
        dist = (marker[0] - contour[j][0])**2 + (marker[1] - contour[j][1])**2
        if dist < mindist:
            mindist = dist
            index = j

    return index

def divide_contour(markers, contour):
    '''
    Divide contour based on the relative positions of markers
    :return: (list, list); two segments from the contour
    '''
    # Find the corresponding positions of the tracked points on contour
    ind_arm1 = locate_point((markers['armpit1_x'], markers['armpit1_y']), contour)
    ind_arm2 = locate_point((markers['armpit2_x'], markers['armpit2_y']), contour)
    ind_ped = locate_point((markers['peduncle_x'], markers['peduncle_y']), contour)

    # Divide the contour into two segments joint at ind_ped
    # marker_hypostome = (markers['hypostome_x'], markers['hypostome_y'])

    marker_hypostome = ((markers['armpit1_x']+markers['armpit2_x'])/2, (markers['armpit1_y']+markers['armpit2_y'])/2)


    if ind_arm1 < ind_arm2 < ind_ped:
        # seg1 = [marker_hypostome] + contour[ind_arm2:ind_ped+1]
        seg1 = contour[ind_arm2:ind_ped+1]
        seg2 = contour[ind_ped:] + contour[0:ind_arm1+1] #+ [marker_hypostome]
        seg2.reverse()
    elif ind_arm1 < ind_ped < ind_arm2:
        seg1 = contour[ind_ped:ind_arm2+1] #+ [marker_hypostome]
        seg1.reverse()
        # seg2 = [marker_hypostome] + contour[ind_arm1:ind_ped+1]
        seg2 = contour[ind_arm1:ind_ped+1]
    elif ind_arm2 < ind_arm1 < ind_ped:
        # seg2 = [marker_hypostome] + contour[ind_arm1:ind_ped+1]
        seg2 = contour[ind_arm1:ind_ped+1]
        seg1 = contour[ind_ped:] + contour[0:ind_arm2+1] #+ [marker_hypostome]
        seg1.reverse()
    elif ind_arm2 < ind_ped < ind_arm1:
        # seg1 = [marker_hypostome] + contour[ind_arm2:ind_ped+1]
        seg1 = contour[ind_arm2:ind_ped+1]
        seg2 = contour[ind_ped:ind_arm1+1] #+ [marker_hypostome]
        seg2.reverse()
    elif ind_ped < ind_arm1 < ind_arm2:
        seg2 = contour[ind_ped:ind_arm1+1] #+ [marker_hypostome]
        seg2.reverse()
        # seg1 = [marker_hypostome] + contour[ind_arm2:] + contour[0:ind_ped+1]
        seg1 = contour[ind_arm2:] + contour[0:ind_ped+1]
    else:
        seg1 = contour[ind_ped:ind_arm2+1] #+ [marker_hypostome]
        seg1.reverse()
        # seg2 = [marker_hypostome] + contour[ind_arm1:] + contour[0:ind_ped+1]
        seg2 = contour[ind_arm1:] + contour[0:ind_ped+1]

    # print(seg2)

    return seg1, seg2

def length_segment(seg):
    '''
    :return: the path-length of seg
    :rtype: float
    '''
    length = 0
    for j in range(len(seg)-1):
        p1, p2 = seg[j], seg[j+1]
        length += np.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)

    return length

def find_midindex(seg):
    '''
    :return: The midpoint index of seg
    :rtype: int
    '''
    length_total = length_segment(seg)
    length = 0
    index = 0

    while length < length_total/2:
        length += length_segment(seg[index:index+2])
        index += 1

    return index

def find_midline(seg1, seg2, max_depth, midpoints = [], sidepoints = [], depth = 0):
    '''
    :return: middle points and corresponding side points on the segments
    :rtype: list(tuple), list((tuple, tuple))
    '''

    if depth <= max_depth:
        midind1 = find_midindex(seg1)
        midind2 = find_midindex(seg2)

        sidepoint1 = seg1[midind1]
        sidepoint2 = seg2[midind2]
        sidepoints.append((sidepoint1, sidepoint2))

        midpoint = ((sidepoint1[0] + sidepoint2[0]) / 2, (sidepoint1[1] + sidepoint2[1]) / 2)
        midpoints.append(midpoint)

        seg11 = seg1[0:midind1+1]
        seg12 = seg1[midind1:]
        seg21 = seg2[0:midind2+1]
        seg22 = seg2[midind2:]

        midpoints, sidepoints = find_midline(seg11, seg21, max_depth, midpoints, sidepoints, depth+1)
        midpoints, sidepoints = find_midline(seg12, seg22, max_depth, midpoints, sidepoints, depth+1)

    return midpoints, sidepoints


def pedunc_trace(file_icy, file_dlc, max_depth , video, scale = (2.0, 2.0)):
    '''
    :return: an array of the integration of fluorescence for each frame of the video
    :rtype: list
    '''
    # Load data
    contours, df, _ = load_data(file_icy, file_dlc)

    # Presettings
    lengths = []
    num_frames = len(contours)
    intensities_ = []
    cap = cv2.VideoCapture(video)

    firstf = True
    iframe = 0
    while True:

        if iframe >= num_frames:
            break
        # Capture frame-by-frame
        ret, frame = cap.read()

        markers = df.iloc[iframe]
        contour = contours[iframe]

        # Pass dropped frames
        if np.isnan(markers[0]):
            # print('drop', iframe)
            iframe += 1
            continue

        # Get midpoints
        seg1, seg2 = divide_contour(markers, contour)
        midpoints, sidepoints = find_midline(seg1, seg2, max_depth, midpoints = [], sidepoints = [])

        # seg1 = np.array(seg1)
        # seg2 = np.array(seg2)
        # Sort midpoints based on the distances with the peduncle point
        ped_point = (markers['peduncle_x'], markers['peduncle_y'])
        hyp_point = ((markers['armpit1_x']+markers['armpit2_x'])/2, (markers['armpit1_y']+markers['armpit2_y'])/2)
        dist_with_ped = [length_segment([p, ped_point]) for p in midpoints]
        indexs = np.argsort(dist_with_ped)
        midpoints = np.array(midpoints)[indexs]
        np.append(midpoints, hyp_point)
        sidepoints = np.array(sidepoints)[indexs]
        # print(sidepoints.shape)
        # Append length of midline
        lengths.append(length_segment(midpoints))
        # Extract coordinates lists
        contour_x = [p[0] for p in contour]
        contour_y = [p[1] for p in contour]
        mid_x = [p[0] for p in midpoints]
        mid_y = [p[1] for p in midpoints]

        side1_x = [p[0][0] for p in sidepoints]
        side1_y = [p[0][1] for p in sidepoints]

        side2_x = [p[1][0] for p in sidepoints]
        side2_y = [p[1][1] for p in sidepoints]

        # get_seg_point()

        side2_x.reverse()
        side2_y.reverse()

        # print(ped_point[0] in side2_x)

        polypoints_x = side1_x + side2_x + [ped_point[0]]
        polypoints_y = side1_y + side2_y + [ped_point[1]]
        length_points = len(polypoints_x)
        # print(length_points)
        polypoints_x = polypoints_x[:int(length_points*0.2)+1] + polypoints_x[-int(length_points*0.2)-2:]
        polypoints_y = polypoints_y[:int(length_points*0.2)+1] + polypoints_y[-int(length_points*0.2)-2:]

        chk = np.where( np.array(seg1)[:,0] == polypoints_x[int(length_points*0.2)] )
        chk1 = np.where( np.array(seg2)[:,0] == polypoints_x[-int(length_points*0.2)-2] )
        seg1ind = int(chk[0][0])
        seg2ind = int(chk1[0][0])
        # print(type(np.array(seg1)[seg1ind:,0]))
        polypoints_x = np.concatenate( ( np.array(seg1)[seg1ind:, 0] , np.flip(np.array(seg2)[seg2ind:, 0] ) ), axis = None )
        polypoints_y = np.concatenate( ( np.array(seg1)[seg1ind:, 1] , np.flip(np.array(seg2)[seg2ind:, 1] ) ), axis = None )

        polypoints = []
        for x,y in zip(polypoints_x, polypoints_y):
            polypoints.append((x,y))

        # print(len(polypoints))
        # poly = Polygon(polypoints)
        plt.clf()
        rframe = cv2.resize(frame, (640, 360))
        plt.imshow(rframe)


        # plt.plot([polypoints[3][0],polypoints[4][0]],[polypoints[3][1],polypoints[4][1]], 'b-')
        # plt.plot(*poly.exterior.xy, )
        plt.fill(polypoints_x, polypoints_y, alpha = 0.5)

        plt.scatter(np.array(seg1)[:,0], np.array(seg1)[:,1], color = '', marker = 'o', edgecolors= 'g')
        plt.scatter(np.array(seg2)[:,0], np.array(seg2)[:,1], color = '', marker = 'o', edgecolors= 'g')
        for i in range(len(side1_x)):
            plt.plot([side1_x[i], side2_x[-i-1]], [side1_y[i], side2_y[-i-1]], color='burlywood')
            # (side2_x[i], side2_y[i], color='maroon', marker ='o')
        plt.plot(mid_x, mid_y, 'r.-')
        plt.plot([markers['armpit1_x'],hyp_point[0]], [markers['armpit1_y'],hyp_point[1]], 'go-')
        plt.plot([markers['armpit2_x'],hyp_point[0]], [markers['armpit2_y'],hyp_point[1]], 'go-')
        plt.plot([hyp_point[0], mid_x[-1]], [hyp_point[1], mid_y[-1]], 'r-')
        plt.plot([ped_point[0], mid_x[0]], [ped_point[1], mid_y[0]], 'r-')
        plt.plot(markers['armpit1_x'], markers['armpit1_y'], 'bo')
        plt.plot(markers['armpit2_x'], markers['armpit2_y'], 'bo')
        plt.plot(hyp_point[0],hyp_point[1], color='orange', marker='o')
        plt.plot(ped_point[0],ped_point[1], color= 'purple', marker = 'o')
        plt.xlim(left = 0, right = 640)
        plt.ylim(bottom = 0, top = 360)

        # plt.scatter(np.array(seg2)[70:,0], np.array(seg2)[70:,1], marker = 'o', color='midnightblue')
        # plt.scatter(np.array(seg1)[35:,0], np.array(seg1)[35:,1], marker = 'o', color='midnightblue')
        # input('press enter')
        plt.pause(0.001)
        plt.savefig('/home/shashank/Downloads/movfig_cont/fig'+str(iframe) +'.png')


        if ret:
            if firstf:
                size = len(frame) * len(frame[0])
                r2,r1, _ignore = np.shape(frame)
                print(r2,r1)
                pt_list = []
                # for i in range(r1):
                #     for j in range(r2):
                #         pt_list.append( Point((i/scale[0], j/scale[1])) )
                firstf = False

            # Our operations on the frame come here
            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
            intensity = 0
            polypoints = np.array( [polypoints], dtype = np.int32)
            # print(polypoints)
            polypoints*=2
            # print(polypoints)
            cframe = np.zeros_like(frame)
            cv2.fillPoly( cframe, polypoints, 1 )
            cframe = cframe * frame
            intensity = np.sum(cframe)

            # input('press enter')
            # intensity = np.sum(frame)
            # for pt in pt_list:
            #     pass
                # np.sum(frame)
                # if poly.contains(pt):
                #     intensity += frame[int(pt.y*2)][int(pt.x *2)]
                # else:
                #     intensity += 0.0
            # par_trace_pt = partial(par_trace, frame = frame, poly = poly)
            # with Pool(9) as pl:
            #     intensity += sum(pl.map(par_trace_pt, pt_list))
            # intensity = np.sum(frame)

            intensities_.append(intensity)

            if cv2.waitKey(1) & 0xFF == ord('q'):
                break
        else:
            break

        # print(iframe)
        iframe += 1


    # Find OpenCV version
    (major_ver, minor_ver, subminor_ver) = (cv2.__version__).split('.')


    # When everything done, release the capture
    cap.release()
    cv2.destroyAllWindows()

    return intensities_



if __name__ == '__main__':

    # lengths = main('../data/hy78clip1_R2.xml', '../data/hy78clip1DeepCut_resnet50_clip1Mar24shuffle1_124000.csv', max_depth = 5)
    lengths = pedunc_trace(sys.argv[1], sys.argv[2], max_depth = int(sys.argv[3]), video=sys.argv[4])
    fig = plt.figure()
    plt.plot(lengths)
    plt.show()
    identifier = sys.argv[1].split('/')[-1].strip('.xml')
    try:
        fig.savefig('output_con/pedunc_fluo_' + identifier + '.png')
    except FileNotFoundError:
        os.makedirs('output_con/')
        fig.savefig('output_con/pedunc_fluo_' + identifier + '.png')
    df = pd.DataFrame(lengths)
    df.to_csv('output_con/pedunc_fluo_' + identifier + '.csv', index=False)
